package lc477;

/**
 * 看着这篇题解，https://blog.csdn.net/fuxuemingzhu/article/details/79494653
 *
 * 4:     0 1 0 0
 *
 * 14:    1 1 1 0
 *
 * 2:     0 0 1 0
 *
 * 1:     0 0 0 1
 *
 * 我们先看最后一列，有三个0和一个1，那么它们之间相互的汉明距离就是3，即1和其他三个0分别的距离累加，
 * 然后在看第三列，累加汉明距离为4，因为每个1都会跟两个0产生两个汉明距离，
 * 同理第二列也是4，第一列是3。
 * 我们仔细观察累计汉明距离和0跟1的个数，我们可以发现其实就是0的个数乘以1的个数，
 * 发现了这个重要的规律，那么整道题就迎刃而解了，只要统计出每一位的1的个数即可。
 * 然后计算1的个数，只需要用二进制异或1即可
 */
public class Solution477 {
    public int totalHammingDistance(int[] nums) {
        int n = nums.length, total = 0;
        // 一共可能最长有32位，每一列都要看下，不够长的时候，后面也全是0，不会影响
        for (int i = 0; i < 32; i++) {
            int bitCount = 0;
            // 每个string都要来计算一下
            for (int j = 0; j < n; j++) {
                // 移动i个位置，就是移动到要计算汉明距离的那一列
                // 每一位异或1得到是否是1（是就是1，不是就是0），加到本轮的bitCount上

                // 如果对bit-manipulation还不熟悉，详细说一下这里的操作
                // 比如你当前的nums[j]是00011110101，此时i=2，那就右移2位
                // nums[j] >> 2 -> 00000111101(前面补零)，然后我们此时和1进行异或，什么意思呢，就是
                // 00000111101 & 00000000001，这下就知道只有最后一位进行了计算，就可以看右移了i位之后
                // 最右边那位是不是1
                bitCount += (nums[j] >> i) & 1;
            }
            total += bitCount * (n - bitCount);
        }
        return total;
    }
}
